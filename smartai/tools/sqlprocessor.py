import re
from pathlib import Path
from typing import Callable

import pandas as pd
from jinja2 import Template


class SQL():
    def __init__(self, data_dictionary: str, dialect: str, ai_callback: Callable[[str], str], connection) -> None:
        self.templates = "prompts/"
        self.data_dictionary = data_dictionary
        self.dialect = dialect
        self.ai_callback = ai_callback
        self.connection = connection

    def _get_template(self, name: str) -> Template:
        """Get the template with the given name.

        Args:
            name (str): name of the template

        Returns:
            Template: Jinja Template object
        """
        return Template(Path(self.templates + name + ".jinja2").read_text())

    def sanitize(self, text: str) -> str:
        """Cleans the text generated by the completion model.
        It aims to first match all the codeblocks and then return the code portions of the text. If no codeblocks are found, it returns the entire text.

        Args:
            text (str): markdown code blocks or raw queries

        Returns:
            str: SQL queries
        """
        pattern = r"```(.*?)\n(.*?)```"
        # check if the text matches the pattern and extract all groups
        match = re.search(pattern, text, re.DOTALL)
        if match:
            text = match.group(2)
        return text.replace("\t", " ").replace("  ", " ").strip()

    def query_generator(self, question: str) -> str:
        """Generates SQL queries from a question.

        Args:
            question (str): Question which gets translated into a SQL query.

        Returns:
            str: SQL queries
        """
        prompt = self._get_template("generate_query").render(
            dialect = self.dialect,
            data_dictionary = self.data_dictionary,
            question=question
        )
        response = self.ai_callback(prompt)
        return self.sanitize(response)
    
    def fix_query(self, question: str, query: str, exception: Exception) -> str:
        """Fixes a query that has failed to execute.

        Args:
            question (str): Question which gets translated into a SQL query.
            query (str): SQL query
            exception (Exception): Exception that was raised

        Returns:
            str: SQL queries
        """
        prompt = self._get_template("fix_query").render(
            dialect = self.dialect,
            data_dictionary = self.data_dictionary,
            question=question,
            query=query,
            exception=str(exception)
        )
        response = self.ai_callback(prompt)
        return self.sanitize(response)
    
    def ask(self, question: str, max_retry: int = 5) -> pd.DataFrame:
        """Ask a question and get the results.

        Args:
            question (str): Question to ask

        Returns:
            pd.DataFrame: Results
        """
        query = self.query_generator(question)
        return self.__process_query(question, query, max_retry=max_retry)

    def __process_query(self, question: str, query: str, max_retry: int = 5) -> pd.DataFrame:
        """Process a query and return the results.

        Args:
            question (str): Question to ask
            query (str): SQL query
            max_retry (int, optional): Maximum number of retries. Defaults to 5.

        Returns:
            pd.DataFrame: Results
        """
        try:
            df = pd.read_sql_query(query, self.connection)
            print(f"Query executed successfully:\n{query}")
            return df
        except pd.errors.DatabaseError as e:
            if max_retry > 0:
                query = self.fix_query(question, query, e)
                return self.__process_query(question, query, max_retry=max_retry - 1)
            else:
                raise e
